https://doc.qt.io/qt-6/signalsandslots.html

# 介绍

在 GUI 编程中，当我们更改一个控件时，常常希望另一个控件被通知到。更一般地说，我们希望**各种对象之间能够相互通信**（communicate）。例如，当用户点击“关闭”按钮时，我们很可能希望窗口的`close()`函数被调用。

其他工具包使用回调（callback）实现这种通信。回调是一个指向函数的指针——如果你希望处理函数向你通知一些事件，你就向该处理函数传递**指向另一个函数的指针**（回调），然后处理函数在适当的时候调用回调。虽然确实存在成功使用此方法的框架，但回调可能不够直观，并且在确保回调实参的类型正确性方面可能会遇到问题。

# 信号和槽

在 Qt 中，我们有一种替代回调技术的方案：使用信号和槽。**信号**（signal）在某个特定事件发生时被发出（emit）。Qt 控件有许多预定义的信号，但我们可以通过继承控件来添加自己定义的信号。**槽**（slot）是为响应特定信号而被调用的函数。Qt 控件有许多预定义的槽，但通常的做法是继承控件然后添加自己定义的槽，以便处理您感兴趣的信号。

![[Pasted image 20250416153227.png]]

- 信号和槽机制是**类型安全**的：信号的签名必须与接收它的槽的签名匹配。（事实上，==槽的签名可以比信号的更短，因为它可以忽略多余的实参==。）由于信号是兼容的，使用基于**函数指针**的句法时，编译器可以帮助我们检测出类型不匹配。而使用基于字符串的 **`SIGNAL`和`SLOT`** 句法时，类型不匹配将在**运行时**被检测出来。
- 信号和槽机制是**松耦合**的：发出信号的类**既不知道也不关心**哪个槽接收该信号。Qt 信号和槽机制确保：如果你将一个信号连接到一个槽，该槽将在适当的时候==使用信号的参数==被调用。
- 信号和槽可以接收**任意数量、任意类型**的实参，它们是完全类型安全的。

==所有继承自`QObject`或其子类（例如`QWidget`）的类都可以包含信号和槽==。

---

当对象改变自己的状态（而这种状态改变可能会引起其他对象的兴趣时）就发出信号。这就是对象为通信所做的全部，它只负责发出信号，而不知道/不关心是否有对象接收自己发出信号。这是真正的信息封装，确保了对象能被用作软件组件。

槽可用于接收信号，但它们同时也是**普通的成员函数**。正如对象不知道是否有对象接收其信号一样，槽也不知道是否有任何信号连接到自己。这确保了用 Qt 可以创建真正独立的组件。

---

可以将**一个**信号连接到**多个**槽，也可以将**多个**信号连接到**一个**槽。

甚至可以直接==将信号连接到另一个信号==（效果：第一个信号发出后，立即发出第二个信号）。

---

信号与槽共同构成了一个强大的组件编程机制。

# 信号

当对象改变自己的状态（而这种状态改变可能会引起其他对象的兴趣时）就发出信号。信号是 **public 成员函数**，可以从任何地方发出，但我们强烈建议==只在定义该信号的类及其派生类中发出。

当信号被发出时，与其连接的槽通常会立即执行，就像普通函数调用一样。这种情况下，信号和槽机制完全独立于任何 GUI 事件循环。==在所有槽函数都返回后，才会继续执行 emit 语句后的代码==。当使用 [queued connections](https://doc.qt.io/qt-6/qt.html#ConnectionType-enum) 时情况略有不同；这种情况下，`emit`关键字后的代码会立即继续执行，槽函数在稍后执行。

==如果有多个槽连接到一个信号，当信号发出时，槽函数会按照它们被连接的顺序依次执行。==

**信号由[moc](https://doc.qt.io/qt-6/moc.html)自动生成，不得在`.cpp`文件中实现。**

关于实参的说明：我们的经验表明，信号和槽会具有更好的可重用性，如果它们不使用特殊类型。例如，如果信号`QScrollBar::valueChanged()`使用了特殊类型（例如假定的 QScrollBar::Range 型），会导致它只能连接到专门为`QScrollBar`设计的槽，无法将不同的输入控件连接在一起。

# 槽

槽函数会在与其连接的信号发出时被调用。**槽是普通的C++函数，并可以被普通地调用**；其唯一的特殊之处是信号可以连接到它们。

由于槽是普通成员函数，直接调用时遵循C++常规规则。然而，作为槽函数，它们可以通过“信号-槽连接”被任何组件调用，不受访问权限的限制。这意味着，即使某个槽函数被声明为`private`，只要信号成功连接，来自其他类实例的信号仍能调用该私有函数。

你还可以**将槽定义为虚函数**，在实践中这非常有用。

与回调相比，信号和槽由于提供了更高的灵活性而性能上稍慢一些，尽管对于实际应用程序来说差异不大。一般来说，通过发射信号调用槽，比直接调用槽（通过非虚函数调用）大约慢十倍。这些开销包括定位连接对象、安全遍历所有连接（即检查后续接收者是否已被销毁）以及以通用方式封送参数。虽然十次非虚函数调用听起来不少，但与任何`new`或`delete`的开销相比要小得多；一旦你执行字符串、vector 或列表这样的需要在幕后使用`new`或`delete`的操作，信号和槽的开销在整个函数调用成本中仅占极小一部分。当你在槽中进行系统调用，或间接调用超过十个函数，情况也是如此。信号和槽机制的简单性和灵活性完全值得这种开销，而且用户根本不会察觉。

> 接收者：即被连接到信号的槽函数所属的对象

